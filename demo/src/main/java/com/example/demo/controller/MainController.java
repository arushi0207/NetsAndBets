package com.example.demo.controller;

import com.example.demo.model.MarchMadnessTeam;
import com.example.demo.model.User;
import com.example.demo.repository.MarchMadnessTeamRepository;
import com.example.demo.repository.UserRepository;
import com.example.demo.service.MarchMadnessScraper;

import java.util.List;
import java.util.Map;
import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

/**
 * This class controls flow to and from the database using GET and POST calls. The backend listens
 * on port 8080 and uses calls to query and modify the database.
 *
 * DEVELOPERS: To access the database and run the backend, you must first open a ssh tunnel with the terminal
 * command below. This terminal will be a different one than you run the backend in:
 *
 * ssh -L localhost:3306:localhost:3306 [CS_USERNAME]@cs506x14.cs.wisc.edu
 */
@Controller // This means that this class is a Controller
@RequestMapping(path="/demo") // This means URL's start with /demo (after Application path)
public class MainController {

    @Autowired // This means to get the bean called userRepository
        // Which is auto-generated by Spring, we will use it to handle the data
    private UserRepository userRepository;

    @Autowired
    private MarchMadnessTeamRepository marchMadnessTeamRepository;

    @Autowired
    private MarchMadnessScraper scraper;

    private final BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();

    /**
     * Adds a new User to the MySQL Database with a unique ID, a username, and a password
     *
     * @param username the user-decided username
     * @param password the user-decided password
     * @return a "saved" string if the user was successfully added to the Database
     */

    @PostMapping(path="/add") // Map ONLY POST Requests
    public @ResponseBody String addNewUser (@RequestParam String username
            , @RequestParam String password) {
        // @ResponseBody means the returned String is the response, now a view name
        // @RequestParam means it is a parameter from the GET or POST request

        User user = new User();
        user.setUsername(username);
        user.setPassword(password);
        userRepository.save(user);
        return "Saved";
    }

    /**
     * Handles user signup by adding a new username and password to the database.
     * 
     * This endpoint allows a new user to create an account by providing a username and password.
     * The password is securely hashed before being stored in the database. If the username 
     * is already taken, an error message is returned.
     * 
     * @param user The user object containing the username and password in the request body.
     * @return A ResponseEntity indicating success or failure while signing up.
     */
    @PostMapping(path = "/signup")
    public ResponseEntity<?> signUpUser(@RequestBody User user) {

        String username = user.getUsername();
        String password = user.getPassword();

        // Check if the username is already taken
        Optional<User> existingUser = userRepository.findByUsername(username);
        if (existingUser.isPresent()) {
            return ResponseEntity.badRequest().body(Map.of("message", "Error: Username is already taken!"));
        }

        // Encode the password before saving it in the database
        String encodedPassword = passwordEncoder.encode(password);
        user.setPassword(encodedPassword);

        // Save the user to the database
        userRepository.save(user);
        return ResponseEntity.ok(Map.of("message", "User signed up successfully!"));
    }

    /**
     * Handles user login by verifying the username and password from the database.
     * 
     * This endpoint allows a new user to create an account by providing a username and password.
     * The password is securely hashed before being stored in the database. If the username 
     * is already taken, an error message is returned.
     * 
     * @param loginRequest The user object containing the username and password in the login form.
     * @return A ResponseEntity indicating success or failure while logging up.
     */
    @PostMapping(path = "/login")
    public ResponseEntity<?> loginUser(@RequestBody User loginRequest) {

        // Find the username in the database
        Optional<User> user = userRepository.findByUsername(loginRequest.getUsername());

        // If the user is not found then return an error
        if (user.isEmpty()) {
            return ResponseEntity.status(404).body("User not found.");
        }

        // If the user's password does not match then return an error
        if (!passwordEncoder.matches(loginRequest.getPassword(), user.get().getPassword())) {
            return ResponseEntity.status(401).body("Incorrect password.");
        }

        // Return successful login
        return ResponseEntity.ok(user);
    }
    
    /*
     * Finds and returns an iterable of all users and user information stored in the MySQL Database
     *
     * @return an Iterable of all users in the database
     */
    @GetMapping(path="/all")
    public @ResponseBody Iterable<User> getAllUsers() {
        // This returns a JSON or XML with the users
        return userRepository.findAll();
    }

    /**
     * Finds and returns a specific user in the MySQL Database by their unique username
     *
     * @param username the username of the given user
     * @return the user entity if it exists, or null if there does not exist a user with the given username
     */
    @GetMapping(path="/user")
    public @ResponseBody Optional<User> getUserByUsername(@RequestParam String username) {
        return userRepository.findByUsername(username);
    }

    // Make get call for specific user

    /**
     * Endpoint to trigger the web scraping process for March Madness teams.
     * This method invokes the scraper to fetch team data and save it to the database.
     *
     * @return A confirmation message indicating that the scraping and saving process has completed.
     */

    @PostMapping(path="/scrape")
    public @ResponseBody String scrapeTeams() {
        scraper.runScraper();
        return "Scraping and saving teams completed!";
    }

    /**
     * Endpoint to return the list of all the March Madness Teams stored in the database.
     * 
     * @return A list of teams including their id, name, seed and region
     */

    @GetMapping(path="/teams")
    public @ResponseBody List<MarchMadnessTeam> getAllTeams() {
        return marchMadnessTeamRepository.findAll();
    }


    /**
     * Place a bet and updates the balance accordingly.
     * 
     * @param betInfo conatins bet information including username, amount, and bet details
     * @return A ResponseEntity indicating success or failure of the bet placement
     */
    @PostMapping(path="/bets")
    public @ResponseBody ResponseEntity<?> bets(@RequestBody Map<String, Object> betInfo) {
        try {
            // Get the username from betInfo
            String username = (String) betInfo.get("username");
            if (username == null) {
                return ResponseEntity.badRequest().body("No username found. Username is required");
            }

            // Find the user by their username
            Optional<User> userObt = userRepository.findByUsername(username);
            if (userObt.isEmpty()) {
                return ResponseEntity.badRequest().body("Could not find the user. Username does not exist");
            }

            User user = userObt.get(); // Get the user object
            // Get bet amt from betInfo
            if (betInfo.get("amount") == null) {
                return ResponseEntity.badRequest().body("No bet amount found. Bet amount is required");
            }
            // Check if bet amt is valid
            if (!(betInfo.get("amount") instanceof Number)) {
                return ResponseEntity.badRequest().body("Bet amount is invalid");
            }
            // Converting the bet amt to double
            double betAmt = ((Number) betInfo.get("amount")).doubleValue();

            // Check if user has enough balance
            if (user.getAmount() < betAmt) {
                return ResponseEntity.badRequest().body("You don't have sufficient balance");
            }

            // Update the user balance accordingly
            user.setAmount(user.getAmount() - betAmt);
            userRepository.save(user);

            // TODO: Save the bet to a table 

            return ResponseEntity.ok(Map.of(
                "message", "Bet placed successfully",
                "newBalance", user.getAmount()
            ));
        } catch (Exception e) {
            return ResponseEntity.badRequest().body("Error placing bet: " + e.getMessage());
        }
    }
}