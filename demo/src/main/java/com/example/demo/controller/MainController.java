package com.example.demo.controller;

import com.example.demo.model.Bet;
import com.example.demo.model.MarchMadnessTeam;
import com.example.demo.model.User;
import com.example.demo.repository.BetRepository;
import com.example.demo.repository.MarchMadnessTeamRepository;
import com.example.demo.repository.UserRepository;
import com.example.demo.service.MarchMadnessScraper;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.ArraySchema;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;

import java.util.List;
import java.util.Map;
import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
//import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

/**
 * This class controls flow to and from the database using GET and POST calls. The backend listens
 * on port 8080 and uses calls to query and modify the database.
 *
 * DEVELOPERS: To access the database and run the backend, you must first open a ssh tunnel with the terminal
 * command below. This terminal will be a different one than you run the backend in:
 *
 * ssh -L localhost:3306:localhost:3306 [CS_USERNAME]@cs506x14.cs.wisc.edu
 */
@Controller // This means that this class is a Controller
@RequestMapping(path="/demo") // This means URL's start with /demo (after Application path)
@Tag(name = "User and Team Management", description = "APIs for user authentication and March Madness team data")
public class MainController {

    @Autowired // This means to get the bean called userRepository
        // Which is auto-generated by Spring, we will use it to handle the data
    private UserRepository userRepository;

    @Autowired
    private MarchMadnessTeamRepository marchMadnessTeamRepository;

    @Autowired
    private MarchMadnessScraper scraper;

    @Autowired
    private BetRepository betRepository;

    private final BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();

    /**
     * Adds a new User to the MySQL Database with a unique ID, a username, and a password
     *
     * @param username the user-decided username
     * @param password the user-decided password
     * @return a "saved" string if the user was successfully added to the Database
     */

    @Operation(summary = "Add a new user", description = "Creates a new user in the database with the provided username and password")
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "User successfully created", 
                    content = @Content(mediaType = "text/plain", schema = @Schema(implementation = String.class))),
        @ApiResponse(responseCode = "400", description = "Invalid input", 
                    content = @Content)
    })
    @PostMapping(path="/add") // Map ONLY POST Requests
    public @ResponseBody String addNewUser (@RequestParam String username
            , @RequestParam String password) {
        // @ResponseBody means the returned String is the response, now a view name
        // @RequestParam means it is a parameter from the GET or POST request

        User user = new User();
        user.setUsername(username);
        user.setPassword(password);
        userRepository.save(user);
        return "Saved";
    }

    /**
     * Handles user signup by adding a new username and password to the database.
     * 
     * This endpoint allows a new user to create an account by providing a username and password.
     * The password is securely hashed before being stored in the database. If the username 
     * is already taken, an error message is returned.
     * 
     * @param user The user object containing the username and password in the request body.
     * @return A ResponseEntity indicating success or failure while signing up.
     */
    @Operation(summary = "User signup", description = "Register a new user with securely hashed password")
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "User signed up successfully", 
                    content = @Content(mediaType = "application/json", 
                    schema = @Schema(implementation = Map.class))),
        @ApiResponse(responseCode = "400", description = "Username already taken", 
                    content = @Content(mediaType = "application/json", 
                    schema = @Schema(implementation = Map.class)))
    })
    @PostMapping(path = "/signup")
    public ResponseEntity<?> signUpUser(@RequestBody User user) {

        String username = user.getUsername();
        String password = user.getPassword();

        // Check if the username is already taken
        Optional<User> existingUser = userRepository.findByUsername(username);
        if (existingUser.isPresent()) {
            return ResponseEntity.badRequest().body(Map.of("message", "Error: Username is already taken!"));
        }

        // Encode the password before saving it in the database
        String encodedPassword = passwordEncoder.encode(password);
        user.setPassword(encodedPassword);

        // Save the user to the database
        userRepository.save(user);
        return ResponseEntity.ok(Map.of("message", "User signed up successfully!"));
    }

    /**
     * Handles user login by verifying the username and password from the database.
     * 
     * This endpoint allows a new user to create an account by providing a username and password.
     * The password is securely hashed before being stored in the database. If the username 
     * is already taken, an error message is returned.
     * 
     * @param loginRequest The user object containing the username and password in the login form.
     * @return A ResponseEntity indicating success or failure while logging up.
     */
    @Operation(summary = "User login", description = "Authenticate user by verifying username and password")
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "Login successful", 
                    content = @Content(mediaType = "application/json", 
                    schema = @Schema(implementation = User.class))),
        @ApiResponse(responseCode = "401", description = "Incorrect password", 
                    content = @Content(mediaType = "text/plain", 
                    schema = @Schema(implementation = String.class))),
        @ApiResponse(responseCode = "404", description = "User not found", 
                    content = @Content(mediaType = "text/plain", 
                    schema = @Schema(implementation = String.class)))
    })
    @PostMapping(path = "/login")
    public ResponseEntity<?> loginUser(@RequestBody User loginRequest) {

        // Find the username in the database
        Optional<User> user = userRepository.findByUsername(loginRequest.getUsername());

        // If the user is not found then return an error
        if (user.isEmpty()) {
            return ResponseEntity.status(404).body("User not found.");
        }

        // If the user's password does not match then return an error
        if (!passwordEncoder.matches(loginRequest.getPassword(), user.get().getPassword())) {
            return ResponseEntity.status(401).body("Incorrect password.");
        }

        // Return successful login
        return ResponseEntity.ok(user);
    }
    
    /*
     * Finds and returns an iterable of all users and user information stored in the MySQL Database
     *
     * @return an Iterable of all users in the database
     */
    @Operation(summary = "Get all users", description = "Retrieves a list of all users in the database")
    @ApiResponse(responseCode = "200", description = "List of all users", 
                content = @Content(mediaType = "application/json", 
                array = @ArraySchema(schema = @Schema(implementation = User.class))))
    @GetMapping(path="/all")
    public @ResponseBody Iterable<User> getAllUsers() {
        // This returns a JSON or XML with the users
        return userRepository.findAll();
    }

    /**
     * Finds and returns a specific user in the MySQL Database by their unique username
     *
     * @param username the username of the given user
     * @return the user entity if it exists, or null if there does not exist a user with the given username
     */
    @Operation(summary = "Get user by username", description = "Retrieves a specific user by their username")
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "User found", 
                    content = @Content(mediaType = "application/json", 
                    schema = @Schema(implementation = User.class))),
        @ApiResponse(responseCode = "404", description = "User not found", 
                    content = @Content)
    })
    @GetMapping(path="/user/{username}")
    public @ResponseBody Optional<User> getUserByUsername(@RequestParam String username) {
        return userRepository.findByUsername(username);
    }

    // Make get call for specific user

    /**
     * Endpoint to trigger the web scraping process for March Madness teams.
     * This method invokes the scraper to fetch team data and save it to the database.
     *
     * @return A confirmation message indicating that the scraping and saving process has completed.
     */

    @Operation(summary = "Scrape March Madness teams", description = "Triggers web scraping to fetch and save team data")
    @ApiResponse(responseCode = "200", description = "Scraping completed", 
                content = @Content(mediaType = "text/plain", 
                schema = @Schema(implementation = String.class)))
    @PostMapping(path="/scrape")
    public @ResponseBody String scrapeTeams() {
        scraper.runScraper();
        return "Scraping and saving teams completed!";
    }

    /**
     * Endpoint to return the list of all the March Madness Teams stored in the database.
     * 
     * @return A list of teams including their id, name, seed and region
     */
    @Operation(summary = "Get all teams", description = "Retrieves all March Madness teams from the database")
    @ApiResponse(responseCode = "200", description = "List of all teams", 
                content = @Content(mediaType = "application/json", 
                array = @ArraySchema(schema = @Schema(implementation = MarchMadnessTeam.class))))
    @GetMapping(path="/teams")
    public @ResponseBody List<MarchMadnessTeam> getAllTeams() {
        return marchMadnessTeamRepository.findAll();
    }


    /**
     * Place a bet and updates the balance accordingly.
     * 
     * @param betInfo conatins bet information including username, amount, and bet details
     * @return A ResponseEntity indicating success or failure of the bet placement
     */
    @PostMapping(path="/bets")
    public @ResponseBody ResponseEntity<?> bets(@RequestBody Map<String, Object> betInfo) {
        try {
            // Get the username from betInfo
            String username = (String) betInfo.get("username");
            if (username == null) {
                return ResponseEntity.badRequest().body("No username found. Username is required");
            }

            // Find the user by their username
            Optional<User> userObt = userRepository.findByUsername(username);
            if (userObt.isEmpty()) {
                return ResponseEntity.badRequest().body("Could not find the user. Username does not exist");
            }

            User user = userObt.get(); // Get the user object
            // Get bet amt from betInfo
            if (betInfo.get("amount") == null) {
                return ResponseEntity.badRequest().body("No bet amount found. Bet amount is required");
            }
            // Check if bet amt is valid
            if (!(betInfo.get("amount") instanceof Number)) {
                return ResponseEntity.badRequest().body("Bet amount is invalid");
            }
            // Converting the bet amt to double
            double betAmt = ((Number) betInfo.get("amount")).doubleValue();

            // Check if user has enough balance
            if (user.getAmount() < betAmt) {
                return ResponseEntity.badRequest().body("You don't have sufficient balance");
            }

            // Update the user balance
            double currAmt = user.getAmount();
            double updatedAmt = Math.round((currAmt - betAmt) * 100.0) / 100.0; // Rounding to 2 dec places
            user.setAmount(updatedAmt);
            userRepository.save(user);

            double odds = ((Number) betInfo.get("odds")).doubleValue();
            double amountToWin = ((Number) betInfo.get("amountToWin")).doubleValue();

            // Get the round number
            Object roundObj = betInfo.get("roundIndex");
            Integer roundIndex = (roundObj instanceof Integer) ? (Integer) roundObj : ((Number) roundObj).intValue();

            // Get either Team A or Team B
            String teamSide = (String) betInfo.get("team");

            // Get the team name for A and B
            String teamA = (String) betInfo.get("teamA");
            String teamB = (String) betInfo.get("teamB");

            // Check the selected team and assign it the team name
            String selectedTeam;
            if ("A".equals(teamSide)) {
                selectedTeam = teamA;
            } else if ("B".equals(teamSide)) {
                selectedTeam = teamB;
            } else {
                return ResponseEntity.badRequest().body("Invalid team side. Must be 'A' or 'B'");
            }

            // Make a new Bet object and set its appropriate fields
            Bet bet = new Bet();
            bet.setUserId(user.getId());
            bet.setTeamsPlaying((String) betInfo.get("matchup"));
            bet.setBettingOdds(odds);
            bet.setAmountBet(betAmt);
            bet.setAmountToWin(amountToWin);
            bet.setStatus("In Progress");
            bet.setRoundIndex(roundIndex);
            bet.setSelectedTeam(selectedTeam);
            bet.setTeam(teamSide);

            betRepository.save(bet); // Save the bet

            return ResponseEntity.ok(Map.of(
                "message", "Bet placed successfully",
                "newBalance", user.getAmount()
            ));
        } catch (Exception e) {
            return ResponseEntity.badRequest().body("Error placing bet: " + e.getMessage());
        }
    }

    /**
     * Gets bets placed by user.
     *
     * @param userId The user whose bets need to be retrieved
     * @return A list of bets placed by user
     */
    @Operation(summary = "Get bets", description = "Gets all the bets placed by a user")
    @ApiResponse(responseCode = "200", description = "All of user's bets", 
                content = @Content(mediaType = "application/json", 
                array = @ArraySchema(schema = @Schema(implementation = Bet.class))))
    @GetMapping(path="/userbets")
    public @ResponseBody List<Bet> getBets(@RequestParam Long userId) {
        return betRepository.findByUserId(userId);
    }

}